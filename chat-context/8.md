## User

[@counter-app.tsx (501:501)](file://{{PROJECT_ROOT}}/src/components/counter-app.tsx#L501:501) please find a way to check linera balance ask deepwiki repo linera-io/linera-protocol or repo linera-io/linera-documentation

## Assistant

I'll search for information about checking Linera balance from the documentation.

**Tool Call: **
Status: Completed

You can check the Linera wallet balance or chain balance using the `linera` command-line interface (CLI) tool. There are two primary commands for querying balances: `linera local-balance` and `linera query-balance` . Additionally, a GraphQL API is available for querying balances programmatically .

### CLI Commands for Balance Inquiry

*   **`linera local-balance`** : This command reads the current native-token balance directly from the local state . It does not synchronize with validators or process pending messages .
    *   **Usage**: `linera local-balance [ACCOUNT]` .
    *   The `ACCOUNT` argument can be `CHAIN-ID:OWNER` for a specific owner's balance or `CHAIN-ID` for the chain's balance . If omitted, it defaults to the chain balance of the default chain in the wallet .
    *   The `linera local-balance` command internally calls the `local_owner_balance` method of the `ChainClient` . This method, in turn, uses `local_balances_with_owner` to query the local node for chain and owner balances .

*   **`linera query-balance`** : This command simulates the execution of one block containing pending messages from the local inbox and then reads the native-token balance . It does not synchronize with validators, so you should run `linera sync` first for an up-to-date balance .
    *   **Usage**: `linera query-balance [ACCOUNT]` .
    *   Similar to `local-balance`, `ACCOUNT` can be `CHAIN-ID:OWNER` or `CHAIN-ID`, defaulting to the chain balance of the default chain .
    *   The `linera query-balance` command executes the `query_owner_balance` method of the `ChainClient` . This method stages block execution to include pending messages and then retrieves the balance .

*   **`linera sync`** : This command synchronizes the local state of the chain with a quorum of validators . It's recommended to run this before `query-balance` for the most accurate balance .
    *   **Usage**: `linera sync [CHAIN_ID]` .

### GraphQL API for Balance Inquiry

You can also query balances using the GraphQL API provided by the `linera service` .
The `NodeService` struct in `linera-service/src/cli_wrappers/wallet.rs` provides an asynchronous `balance` method . This method constructs a GraphQL query to fetch the balance for a given `Account` .

*   For a chain balance (where `owner` is `AccountOwner::CHAIN`), the query looks like:
    ```graphql
    query {
        chain(chainId:"{chain}") {
            executionState { system { balance } }
        }
    }
    ```
    
*   For a specific owner's balance, the query is:
    ```graphql
    query {
        chain(chainId:"{chain}") {
            executionState { system { balances {
                entry(key:"{owner}") { value }
            } } }
        }
    }
    ```
    

### Example Usage

The `README.md` provides a quickstart guide with examples of querying chain balances using `linera query-balance`  and user balances .

## Notes

The `linera sync-balance` command is deprecated . The recommended approach is to use `linera sync && linera query-balance` .

The `linera-sdk/wit/base-runtime-api.wit` file defines `read-chain-balance` and `read-owner-balance` functions , which are used internally by the runtime for smart contracts to access balance information . Similarly, `linera-execution/solidity/Linera.sol` contains Solidity functions `read_chain_balance()` and `read_owner_balance()` for EVM contracts . These are internal API calls for applications running on the Linera protocol, not direct user commands.

Wiki pages you might want to explore:
- [Architecture Overview (linera-io/linera-protocol)](/wiki/linera-io/linera-protocol#1.1)

View this search on DeepWiki: https://deepwiki.com/search/how-to-check-linera-wallet-bal_01545ca5-63e5-4e14-bfbb-e3d1f42acd4c


**Tool Call: **
Status: Completed

You can check your Linera wallet balance or chain balance using the `linera query-balance` command . This command evaluates the local balance of your chain .

To use `linera query-balance`, you first need to ensure your wallet is synchronized with the network by running `linera sync` .

The exact commands depend on the type of devnet you are using:

### Single-Node Devnet 
After starting the devnet with `linera net up --with-faucet --faucet-port 8080`  and initializing your wallet , you can query the balance with:
```bash
linera sync 
linera query-balance 
```
This should output a number, such as `10` .

### Docker Compose Devnet 
When using a Docker Compose devnet, you need to specify the wallet and storage files. After running `./compose.sh` , use the following commands:
```bash
linera --wallet wallet.json --storage rocksdb:linera.db sync 
linera --wallet wallet.json --storage rocksdb:linera.db query-balance 
```
The expected output will show the balance, for example, `10.` .

### Kubernetes (`kind`) Devnet 
For a `kind` devnet, after starting it with `linera net up --kubernetes` , you will be provided with environment variables for your wallet configuration . Export these variables and then use:
```bash
linera sync 
linera query-balance 
```
Note that the `linera sync-balance` command is deprecated  and you should use `linera sync && linera query-balance` instead . The initial balance in `kind` devnets is typically `1000000` .

## Notes
The `linera wallet show` command can be used to list chains in your wallet with metadata, but it does not display the balance . The `linera service` command exposes a GraphQL API, which can be used to query application-specific data, but not directly the wallet or chain balance .

Wiki pages you might want to explore:
- [Devnets for Development (linera-io/linera-documentation)](/wiki/linera-io/linera-documentation#6.1)

View this search on DeepWiki: https://deepwiki.com/search/how-to-check-linera-wallet-bal_ae0b8723-7718-4efb-af66-d0ebe0fbabf9


## Assistant

Based on the DeepWiki research, here's how to check Linera balance:

## CLI Commands

### 1. Query Balance (recommended)
```bash
linera sync              # Sync with validators first
linera query-balance     # Query balance after sync
```

### 2. Local Balance (reads from local state without sync)
```bash
linera local-balance [ACCOUNT]
```

The `ACCOUNT` argument can be:
- `CHAIN-ID:OWNER` - for a specific owner's balance
- `CHAIN-ID` - for the chain's balance
- Omitted - defaults to the default chain's balance

## GraphQL API

If using `linera service`, you can query via GraphQL:

**For chain balance:**
```graphql
query {
  chain(chainId: "YOUR_CHAIN_ID") {
    executionState { system { balance } }
  }
}
```

**For owner balance:**
```graphql
query {
  chain(chainId: "YOUR_CHAIN_ID") {
    executionState { system { balances {
      entry(key: "OWNER") { value }
    } } }
  }
}
```

## Note
The `linera sync-balance` command is **deprecated**. Use `linera sync && linera query-balance` instead.

---

Would you like me to help integrate balance checking into your application, perhaps by adding a GraphQL query to your existing Linera service code?

## User

no please search on how to check balance in the frontend instead of using the service because linera service has its own wallet we also got our own wallet based on chainId [@linera-adapter.ts (55:56)](file://{{PROJECT_ROOT}}/src/lib/linera-adapter.ts#L55:56) you can see here we had our own wallet and chainId from that so basically ask the docs how to check balance based on chainId

## Assistant

I'll search for how to check balance in the frontend using the web SDK based on a chainId.

**Tool Call: **
Status: Completed

You are asking how to check the balance of a chain using its `chainId` from a browser JavaScript environment, specifically without relying on a `linera service`, and how to use a faucet wallet for this purpose.

The `@linera/client` package provides a `Client` class that allows you to interact with the Linera protocol from a web frontend . This `Client` class includes an asynchronous method `balance()`  which returns the balance of the default chain as a string.

To use a faucet wallet, you would first create a `JsFaucet` instance with the faucet's URL . Then, you can create a new wallet using `faucet.createWallet()`  and claim a new chain with `faucet.claimChain()` . The `claimChain` method assigns the new chain to an `AccountOwner` and returns the `ChainId` as a string .

The `Client`'s `balance()` method internally calls `query_balance()` on a `ChainClient` . The `ChainClient::query_balance()` method obtains the local balance of the chain account after staging the execution of incoming messages in a new block . It does not attempt to synchronize with validators, reflecting only up to `max_pending_message_bundles` incoming message bundles and execution fees for a single block .

The `linera` CLI tool also provides commands like `linera query-balance`  and `linera local-balance`  to check balances. `linera query-balance` simulates the execution of pending messages and reads the balance , while `linera local-balance` reads the balance directly from the local state without processing pending messages . These CLI commands are implemented in `linera-service/src/cli/main.rs` .

## Notes

The prompt mentions "without linera service". While the `@linera/client` package is designed for frontend web SDK usage, it still interacts with the Linera network, which is typically composed of validator nodes that could be considered part of a "Linera service" in a broader sense. However, the direct interaction is through the client library, not by running a local `linera-server` instance. The `linera-service` crate provides the CLI wallet and server implementations . The `linera-sdk` also provides `chain_balance()` and `owner_balance()` functions for contracts and services running on the chain , but these are for on-chain logic, not for browser-based JavaScript.

Wiki pages you might want to explore:
- [Architecture Overview (linera-io/linera-protocol)](/wiki/linera-io/linera-protocol#1.1)

View this search on DeepWiki: https://deepwiki.com/search/how-to-check-balance-in-fronte_349af3f2-87df-4fe4-8429-1f42c6ac857b


**Tool Call: **
Status: Completed

To check the chain balance in a web frontend using the Linera JavaScript SDK, you can use the `@linera/client` library. This involves initializing the client library, connecting to a faucet to obtain a wallet and chain, and then querying the application backend for the balance. 

### Setting up the Frontend Environment

First, ensure your browser supports necessary features like import maps, `SharedArrayBuffer`, WebAssembly threading primitives, and top-level `await` . You'll need a basic HTML page and a web server that sets `Cross-Origin-Opener-Policy` and `Cross-Origin-Embedder-Policy` headers for `SharedArrayBuffer` to work . The `@linera/client` library can be installed via npm .

### Querying the Balance

1.  **Import the Linera client library**: Add an import map to your HTML `<head>` to make `@linera/client` available . Then, import it in your JavaScript module .
2.  **Initialize the client library**: Call `linera.default()` to download and initialize the WebAssembly binary .
3.  **Get a wallet and claim a chain**: Use the `linera.Faucet` class to connect to a faucet (e.g., Testnet faucet) and create a new wallet. Then, claim a new chain using `faucet.claimChain(client)` . This process also provides initial tokens for testing .
4.  **Communicate with the application**: Obtain an object representing the application backend using `client.application(applicationId)` .
5.  **Query the balance**: Use the `backend.query()` method with a GraphQL query to retrieve the balance. For example, `backend.query('{ "query": "query { value }" }')` can be used for a counter application to get its value . The response will be a JSON string that you can parse to extract the balance .

### Example Code Flow

```javascript
import * as linera from '@linera/client'; 

// Initialize the Linera client library
await linera.default(); 

// Connect to the faucet and create a wallet
const faucet = await new linera.Faucet(
  'https://faucet.{{#include ../../../TESTNET_DOMAIN}}.linera.net',
); 
const wallet = await faucet.createWallet(); 
const client = await new linera.Client(wallet); 

// Claim a chain and get its ID
const chainId = await faucet.claimChain(client); 
document.getElementById('chain-id').innerText = chainId; 

// Assuming you have an application ID (e.g., for a counter app)
const COUNTER_APP_ID = '2b1a0df8868206a4b7d6c2fdda911e4355d6c0115b896d4947ef8e535ee3c6b8'; 
const backend = await client.frontend().application(COUNTER_APP_ID); 

// Function to update the balance/count
async function updateCount() { 
  const response = await backend.query('{ "query": "query { value }" }'); 
  document.getElementById('count').innerText = JSON.parse(response).data.value; 
}

updateCount(); 

// Listen for notifications to update the balance in real-time
client.onNotification(notification => { 
  if (notification.reason.NewBlock) updateCount(); 
});
```

## Notes

The provided context primarily focuses on using the `linera` CLI for development and testing, and the `linera-io/linera-documentation` repository contains documentation for both backend and frontend development. The `linera sync` and `linera query-balance` commands are CLI-specific for checking balances . The web frontend JavaScript SDK uses a different approach by interacting with a `linera.Client` and querying application-specific GraphQL endpoints . The `chainId` is obtained when claiming a chain from the faucet .

Wiki pages you might want to explore:
- [Devnets for Development (linera-io/linera-documentation)](/wiki/linera-io/linera-documentation#6.1)

View this search on DeepWiki: https://deepwiki.com/search/how-to-check-chain-balance-in_b1b18685-3dbe-4f4c-ae41-2ef56b9c6e99


## Assistant

Based on the DeepWiki research, the `@linera/client` package provides a `Client` class with a `balance()` method. Let me check your current code to see how to integrate this.

**Tool Call: src/lib/linera-loader.ts**
Status: Completed

<file>
00001| // Dynamic loader for Linera WASM from public folder
00002| // This avoids the file:// URL issue with @linera/client's bundled import.meta.url
00003| 
00004| let lineraModule: typeof import("@linera/client") | null = null;
00005| 
00006| export async function loadLinera(): Promise<typeof import("@linera/client")> {
00007|     if (lineraModule) return lineraModule;
00008| 
00009|     // Dynamically import the JS module from public folder
00010|     const module = await import(
00011|     /* webpackIgnore: true */ "/linera/linera_web.js"
00012|     );
00013| 
00014|     // Initialize with the WASM file from public folder
00015|     await module.default("/linera/linera_web_bg.wasm");
00016| 
00017|     lineraModule = module;
00018|     return module;
00019| }
00020| 

(End of file - total 20 lines)
</file>

**Tool Call: src/components/counter-app.tsx**
Status: Completed

<file>
00001| "use client";
00002| 
00003| import { useCallback, useEffect, useRef, useState } from "react";
00004| import { useDynamicContext, useIsLoggedIn } from "@dynamic-labs/sdk-react-core";
00005| import { DynamicWidget } from "@dynamic-labs/sdk-react-core";
00006| import { lineraAdapter, type LineraProvider } from "@/lib/linera-adapter";
00007| 
00008| interface BlockLog {
00009|   height: number;
00010|   hash: string;
00011| }
00012| 
00013| interface DomainQueryResult {
00014|   Owner?: string | null;
00015|   IsAvailable?: boolean;
00016| }
00017| 
00018| interface DomainInfo {
00019|   name: string;
00020|   owner: string;
00021| }
00022| 
00023| export default function CounterApp() {
00024|   const { primaryWallet } = useDynamicContext();
00025|   const isLoggedIn = useIsLoggedIn();
00026|   const [mounted, setMounted] = useState(false);
00027|   const [chainId, setChainId] = useState<string | null>(null);
00028|   const [registryChainId, setRegistryChainId] = useState<string | null>(null);
00029|   const [logs, setLogs] = useState<BlockLog[]>([]);
00030|   const [error, setError] = useState<string | null>(null);
00031| 
00032|   const providerRef = useRef<LineraProvider | null>(null);
00033|   const [chainConnected, setChainConnected] = useState(false);
00034|   const [appConnected, setAppConnected] = useState(false);
00035|   const [isAutoConnecting, setIsAutoConnecting] = useState(false);
00036| 
00037|   // Domain registration state
00038|   const [domainName, setDomainName] = useState("");
00039|   const [searchResult, setSearchResult] = useState<DomainQueryResult | null>(
00040|     null,
00041|   );
00042|   const [isSearching, setIsSearching] = useState(false);
00043|   const [isRegistering, setIsRegistering] = useState(false);
00044|   const [allDomains, setAllDomains] = useState<DomainInfo[]>([]);
00045|   const [isLoadingDomains, setIsLoadingDomains] = useState(false);
00046| 
00047|   const applicationId = process.env.NEXT_PUBLIC_LINERA_APPLICATION_ID || "";
00048| 
00049|   useEffect(() => {
00050|     setMounted(true);
00051|     setChainConnected(lineraAdapter.isChainConnected());
00052|     setAppConnected(lineraAdapter.isApplicationSet());
00053|   }, []);
00054| 
00055|   // Auto-connect to Linera when wallet is connected
00056|   const autoConnect = useCallback(async () => {
00057|     if (!primaryWallet || !applicationId || isAutoConnecting) return;
00058|     if (chainConnected && appConnected) return;
00059| 
00060|     setIsAutoConnecting(true);
00061|     setError(null);
00062| 
00063|     try {
00064|       // Connect to Linera chain
00065|       if (!chainConnected) {
00066|         const provider = await lineraAdapter.connect(primaryWallet);
00067|         providerRef.current = provider;
00068|         setChainConnected(true);
00069|         setChainId(provider.chainId);
00070|       }
00071| 
00072|       // Connect to application
00073|       if (!appConnected && applicationId) {
00074|         await lineraAdapter.setApplication(applicationId);
00075|         setAppConnected(true);
00076|       }
00077|     } catch (err) {
00078|       console.error("Auto-connect failed:", err);
00079|       setError(
00080|         err instanceof Error ? err.message : "Failed to auto-connect to Linera",
00081|       );
00082|     } finally {
00083|       setIsAutoConnecting(false);
00084|     }
00085|   }, [
00086|     primaryWallet,
00087|     applicationId,
00088|     chainConnected,
00089|     appConnected,
00090|     isAutoConnecting,
00091|   ]);
00092| 
00093|   useEffect(() => {
00094|     if (mounted && isLoggedIn && primaryWallet && !chainConnected) {
00095|       autoConnect();
00096|     }
00097|   }, [mounted, isLoggedIn, primaryWallet, chainConnected, autoConnect]);
00098| 
00099|   // Reset Linera adapter when Dynamic wallet disconnects
00100|   useEffect(() => {
00101|     if (!isLoggedIn || !primaryWallet) {
00102|       lineraAdapter.reset();
00103|       providerRef.current = null;
00104|       setChainConnected(false);
00105|       setAppConnected(false);
00106|       setChainId(null);
00107|       setRegistryChainId(null);
00108|       setLogs([]);
00109|       setError(null);
00110|       setSearchResult(null);
00111|       setAllDomains([]);
00112|     }
00113|   }, [isLoggedIn, primaryWallet]);
00114| 
00115|   useEffect(() => {
00116|     if (!chainConnected || !providerRef.current) return;
00117|     const client = providerRef.current.client;
00118|     if (!client || typeof client.onNotification !== "function") return;
00119| 
00120|     const handler = (notification: unknown) => {
00121|       const newBlock: BlockLog | undefined = (
00122|         notification as { reason: { NewBlock: BlockLog } }
00123|       )?.reason?.NewBlock;
00124|       if (!newBlock) return;
00125|       setLogs((prev) => [newBlock, ...prev]);
00126|     };
00127| 
00128|     try {
00129|       client.onNotification(handler);
00130|     } catch (err) {
00131|       console.error("Failed to set notification handler:", err);
00132|     }
00133|     return () => {};
00134|   }, [chainConnected]);
00135| 
00136|   // Fetch registry chain ID
00137|   const fetchRegistryInfo = useCallback(async () => {
00138|     if (!appConnected) return;
00139| 
00140|     try {
00141|       const registryResult = await lineraAdapter.queryApplication<{
00142|         data?: { registryChainId: string | null };
00143|         errors?: Array<{ message: string }>;
00144|       }>({
00145|         query: `query { registryChainId }`,
00146|       });
00147|       if (registryResult.data?.registryChainId) {
00148|         setRegistryChainId(registryResult.data.registryChainId);
00149|       }
00150|     } catch (err) {
00151|       console.error("Failed to fetch registry chain ID:", err);
00152|     }
00153|   }, [appConnected]);
00154| 
00155|   // Fetch all registered domains from registry chain
00156|   const fetchAllDomains = useCallback(async () => {
00157|     if (!appConnected || !registryChainId) return;
00158|     setIsLoadingDomains(true);
00159| 
00160|     try {
00161|       // Query the registry chain directly for authoritative data
00162|       const result = await lineraAdapter.queryApplicationOnChain<{
00163|         data?: { allDomains: DomainInfo[] };
00164|         errors?: Array<{ message: string }>;
00165|       }>(registryChainId, applicationId, `query { allDomains { name owner } }`);
00166|       if (result.errors?.length) {
00167|         throw new Error(result.errors[0].message);
00168|       }
00169|       setAllDomains(result.data?.allDomains || []);
00170|     } catch (err) {
00171|       console.error("Failed to fetch all domains:", err);
00172|     } finally {
00173|       setIsLoadingDomains(false);
00174|     }
00175|   }, [appConnected, registryChainId, applicationId]);
00176| 
00177|   // Fetch registry info when app is connected
00178|   useEffect(() => {
00179|     if (appConnected) {
00180|       fetchRegistryInfo();
00181|     }
00182|   }, [appConnected, fetchRegistryInfo]);
00183| 
00184|   // Fetch all domains when registry chain ID is available
00185|   useEffect(() => {
00186|     if (appConnected && registryChainId) {
00187|       fetchAllDomains();
00188|     }
00189|   }, [appConnected, registryChainId, fetchAllDomains]);
00190| 
00191|   async function handleCheckDomain() {
00192|     if (!domainName.trim()) {
00193|       setError("Please enter a domain name");
00194|       return;
00195|     }
00196|     if (!registryChainId) {
00197|       setError("Registry chain ID not available yet");
00198|       return;
00199|     }
00200|     setIsSearching(true);
00201|     setError(null);
00202|     setSearchResult(null);
00203| 
00204|     try {
00205|       // Query the registry chain directly for authoritative data
00206|       const result = await lineraAdapter.queryApplicationOnChain<{
00207|         data?: { isAvailable: boolean };
00208|         errors?: Array<{ message: string }>;
00209|       }>(
00210|         registryChainId,
00211|         applicationId,
00212|         `query { isAvailable(name: "${domainName.trim()}") }`,
00213|       );
00214|       if (result.errors?.length) {
00215|         throw new Error(result.errors[0].message);
00216|       }
00217|       setSearchResult({ IsAvailable: result.data?.isAvailable });
00218|     } catch (err) {
00219|       console.error("Failed to check domain:", err);
00220|       setError(
00221|         err instanceof Error
00222|           ? err.message
00223|           : "Failed to check domain availability",
00224|       );
00225|     } finally {
00226|       setIsSearching(false);
00227|     }
00228|   }
00229| 
00230|   async function handleRegisterDomain() {
00231|     if (!domainName.trim()) {
00232|       setError("Please enter a domain name");
00233|       return;
00234|     }
00235|     setIsRegistering(true);
00236|     setError(null);
00237| 
00238|     try {
00239|       const result = await lineraAdapter.queryApplication<{
00240|         data?: { register: boolean };
00241|         errors?: Array<{ message: string }>;
00242|       }>({
00243|         query: `mutation { register(name: "${domainName.trim()}") }`,
00244|       });
00245| 
00246|       if (result.errors?.length) {
00247|         throw new Error(result.errors[0].message);
00248|       }
00249| 
00250|       if (result.data?.register) {
00251|         setSearchResult({ IsAvailable: false });
00252|         setError(null);
00253|         alert(
00254|           `Domain ${domainName.trim()}.linera registration submitted! It may take a moment to be confirmed.`,
00255|         );
00256|         // Refresh domains list after registration
00257|         setTimeout(() => fetchAllDomains(), 2000);
00258|       }
00259|     } catch (err) {
00260|       console.error("Failed to register domain:", err);
00261|       setError(
00262|         err instanceof Error ? err.message : "Failed to register domain",
00263|       );
00264|     } finally {
00265|       setIsRegistering(false);
00266|     }
00267|   }
00268| 
00269|   async function handleLookupOwner() {
00270|     if (!domainName.trim()) {
00271|       setError("Please enter a domain name");
00272|       return;
00273|     }
00274|     if (!registryChainId) {
00275|       setError("Registry chain ID not available yet");
00276|       return;
00277|     }
00278|     setIsSearching(true);
00279|     setError(null);
00280|     setSearchResult(null);
00281| 
00282|     try {
00283|       // Query the registry chain directly for authoritative data
00284|       const result = await lineraAdapter.queryApplicationOnChain<{
00285|         data?: { owner: string | null };
00286|         errors?: Array<{ message: string }>;
00287|       }>(
00288|         registryChainId,
00289|         applicationId,
00290|         `query { owner(name: "${domainName.trim()}") }`,
00291|       );
00292|       if (result.errors?.length) {
00293|         throw new Error(result.errors[0].message);
00294|       }
00295|       setSearchResult({ Owner: result.data?.owner });
00296|     } catch (err) {
00297|       console.error("Failed to lookup owner:", err);
00298|       setError(
00299|         err instanceof Error ? err.message : "Failed to lookup domain owner",
00300|       );
00301|     } finally {
00302|       setIsSearching(false);
00303|     }
00304|   }
00305| 
00306|   return (
00307|     <div className="flex min-h-screen items-center justify-center bg-zinc-50 font-sans dark:bg-black">
00308|       <div className="w-full max-w-3xl px-6 py-12">
00309|         <div className="rounded-xl bg-white p-8 shadow-lg dark:bg-zinc-900">
00310|           <div className="mb-8 flex items-center justify-between">
00311|             <h1 className="text-3xl font-bold text-zinc-900 dark:text-white">
00312|               Linera Name System
00313|             </h1>
00314|             <DynamicWidget />
00315|           </div>
00316| 
00317|           <div className="mb-8">
00318|             <p className="mb-2 text-zinc-600 dark:text-zinc-400">
00319|               Register your unique .linera domain on the Linera blockchain.
00320|             </p>
00321|             <p className="text-zinc-600 dark:text-zinc-400">
00322|               Connect your wallet to get started. Your chain will be
00323|               automatically claimed from the testnet faucet.
00324|             </p>
00325|           </div>
00326| 
00327|           {error && (
00328|             <div className="mb-6 rounded-lg bg-red-50 p-4 dark:bg-red-900/20">
00329|               <p className="text-red-500 dark:text-red-300">{error}</p>
00330|             </div>
00331|           )}
00332| 
00333|           {/* Connection Status */}
00334|           {mounted && isAutoConnecting && (
00335|             <div className="mb-6 flex items-center justify-center gap-2 rounded-lg bg-sky-50 p-4 dark:bg-sky-900/20">
00336|               <div className="h-4 w-4 animate-spin rounded-full border-2 border-sky-600 border-t-transparent" />
00337|               <p className="text-sky-600 dark:text-sky-400">
00338|                 Connecting to Linera testnet...
00339|               </p>
00340|             </div>
00341|           )}
00342| 
00343|           {mounted && !isLoggedIn && (
00344|             <div className="mb-6 rounded-lg bg-zinc-100 p-6 text-center dark:bg-zinc-800">
00345|               <p className="text-zinc-500 dark:text-zinc-400">
00346|                 Please connect your wallet using the button above to get
00347|                 started.
00348|               </p>
00349|             </div>
00350|           )}
00351| 
00352|           {/* Domain Registration UI */}
00353|           {chainConnected && appConnected && (
00354|             <div className="space-y-6">
00355|               <div className="rounded-lg bg-zinc-100 p-6 dark:bg-zinc-800">
00356|                 <h2 className="mb-4 text-lg font-semibold text-zinc-900 dark:text-white">
00357|                   Search & Register Domain
00358|                 </h2>
00359|                 <div className="flex gap-2">
00360|                   <div className="relative flex-1">
00361|                     <input
00362|                       type="text"
00363|                       value={domainName}
00364|                       onChange={(e) =>
00365|                         setDomainName(
00366|                           e.target.value
00367|                             .toLowerCase()
00368|                             .replace(/[^a-z0-9-]/g, ""),
00369|                         )
00370|                       }
00371|                       placeholder="Enter domain name"
00372|                       className="w-full rounded-lg border border-zinc-300 bg-white px-4 py-3 pr-20 text-zinc-900 placeholder-zinc-400 focus:border-sky-500 focus:outline-none focus:ring-1 focus:ring-sky-500 dark:border-zinc-600 dark:bg-zinc-900 dark:text-white dark:placeholder-zinc-500"
00373|                     />
00374|                     <span className="absolute right-4 top-1/2 -translate-y-1/2 text-zinc-400 dark:text-zinc-500">
00375|                       .linera
00376|                     </span>
00377|                   </div>
00378|                 </div>
00379|                 <div className="mt-4 flex gap-2">
00380|                   <button
00381|                     type="button"
00382|                     onClick={handleCheckDomain}
00383|                     disabled={isSearching || !domainName.trim()}
00384|                     className="flex-1 rounded-lg bg-zinc-200 px-4 py-2 font-medium text-zinc-800 transition-colors hover:bg-zinc-300 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-zinc-700 dark:text-zinc-200 dark:hover:bg-zinc-600"
00385|                   >
00386|                     {isSearching ? "Checking..." : "Check Availability"}
00387|                   </button>
00388|                   <button
00389|                     type="button"
00390|                     onClick={handleLookupOwner}
00391|                     disabled={isSearching || !domainName.trim()}
00392|                     className="flex-1 rounded-lg bg-zinc-200 px-4 py-2 font-medium text-zinc-800 transition-colors hover:bg-zinc-300 disabled:cursor-not-allowed disabled:opacity-50 dark:bg-zinc-700 dark:text-zinc-200 dark:hover:bg-zinc-600"
00393|                   >
00394|                     Lookup Owner
00395|                   </button>
00396|                 </div>
00397| 
00398|                 {searchResult && (
00399|                   <div className="mt-4 rounded-lg bg-white p-4 dark:bg-zinc-900">
00400|                     {searchResult.IsAvailable !== undefined && (
00401|                       <div className="flex items-center justify-between">
00402|                         <div>
00403|                           <p className="font-medium text-zinc-900 dark:text-white">
00404|                             {domainName}.linera
00405|                           </p>
00406|                           <p
00407|                             className={
00408|                               searchResult.IsAvailable
00409|                                 ? "text-green-600 dark:text-green-400"
00410|                                 : "text-red-600 dark:text-red-400"
00411|                             }
00412|                           >
00413|                             {searchResult.IsAvailable
00414|                               ? "Available!"
00415|                               : "Already registered"}
00416|                           </p>
00417|                         </div>
00418|                         {searchResult.IsAvailable && (
00419|                           <button
00420|                             type="button"
00421|                             onClick={handleRegisterDomain}
00422|                             disabled={isRegistering}
00423|                             className="rounded-lg bg-sky-600 px-6 py-2 font-medium text-white transition-colors hover:bg-sky-700 disabled:cursor-not-allowed disabled:opacity-50"
00424|                           >
00425|                             {isRegistering ? "Registering..." : "Register"}
00426|                           </button>
00427|                         )}
00428|                       </div>
00429|                     )}
00430|                     {searchResult.Owner !== undefined && (
00431|                       <div>
00432|                         <p className="font-medium text-zinc-900 dark:text-white">
00433|                           {domainName}.linera
00434|                         </p>
00435|                         <p className="text-sm text-zinc-500 dark:text-zinc-400">
00436|                           Owner:
00437|                         </p>
00438|                         <p className="break-all font-mono text-sm text-zinc-700 dark:text-zinc-300">
00439|                           {searchResult.Owner || "Not registered"}
00440|                         </p>
00441|                       </div>
00442|                     )}
00443|                   </div>
00444|                 )}
00445|               </div>
00446| 
00447|               {/* All Registered Domains */}
00448|               <div className="rounded-lg bg-zinc-100 p-6 dark:bg-zinc-800">
00449|                 <div className="mb-4 flex items-center justify-between">
00450|                   <h2 className="text-lg font-semibold text-zinc-900 dark:text-white">
00451|                     Registered Domains
00452|                   </h2>
00453|                   <button
00454|                     type="button"
00455|                     onClick={fetchAllDomains}
00456|                     disabled={isLoadingDomains}
00457|                     className="rounded-lg bg-zinc-200 px-3 py-1 text-sm font-medium text-zinc-700 transition-colors hover:bg-zinc-300 disabled:opacity-50 dark:bg-zinc-700 dark:text-zinc-300 dark:hover:bg-zinc-600"
00458|                   >
00459|                     {isLoadingDomains ? "Loading..." : "Refresh"}
00460|                   </button>
00461|                 </div>
00462|                 {allDomains.length === 0 ? (
00463|                   <p className="text-zinc-500 dark:text-zinc-400">
00464|                     {isLoadingDomains
00465|                       ? "Loading domains..."
00466|                       : "No domains registered yet."}
00467|                   </p>
00468|                 ) : (
00469|                   <ul className="max-h-48 space-y-2 overflow-y-auto">
00470|                     {allDomains.map((domain) => (
00471|                       <li
00472|                         key={domain.name}
00473|                         className="rounded-lg bg-white p-3 dark:bg-zinc-900"
00474|                       >
00475|                         <p className="font-medium text-zinc-900 dark:text-white">
00476|                           {domain.name}.linera
00477|                         </p>
00478|                         <p className="truncate text-xs text-zinc-500 dark:text-zinc-400">
00479|                           Owner: {domain.owner.slice(0, 16)}...
00480|                           {domain.owner.slice(-8)}
00481|                         </p>
00482|                       </li>
00483|                     ))}
00484|                   </ul>
00485|                 )}
00486|               </div>
00487|             </div>
00488|           )}
00489| 
00490|           {/* Chain Info */}
00491|           {chainConnected && (
00492|             <div className="mt-8 space-y-4 border-t border-zinc-200 pt-6 dark:border-zinc-700">
00493|               <div className="flex items-center gap-2">
00494|                 <div className="h-2 w-2 rounded-full bg-green-500" />
00495|                 <span className="text-sm text-zinc-600 dark:text-zinc-400">
00496|                   Connected to Linera Testnet
00497|                 </span>
00498|               </div>
00499|               <div className="space-y-2 text-sm">
00500|                 <p className="text-zinc-700 dark:text-zinc-300">
00501|                   <span className="font-medium">Your Chain ID:</span>{" "}
00502|                   <code className="break-all rounded bg-zinc-100 px-2 py-1 font-mono text-xs text-zinc-600 dark:bg-zinc-800 dark:text-zinc-400">
00503|                     {chainId
00504|                       ? `${chainId.slice(0, 16)}...${chainId.slice(-8)}`
00505|                       : "..."}
00506|                   </code>
00507|                 </p>
00508|                 {registryChainId && (
00509|                   <p className="text-zinc-700 dark:text-zinc-300">
00510|                     <span className="font-medium">Registry Chain ID:</span>{" "}
00511|                     <code className="break-all rounded bg-zinc-100 px-2 py-1 font-mono text-xs text-zinc-600 dark:bg-zinc-800 dark:text-zinc-400">
00512|                       {registryChainId.slice(0, 16)}...
00513|                       {registryChainId.slice(-8)}
00514|                     </code>
00515|                   </p>
00516|                 )}
00517|                 <p className="text-zinc-500 dark:text-zinc-500">
00518|                   Application ID:{" "}
00519|                   <code className="break-all font-mono text-xs">
00520|                     {applicationId.slice(0, 16)}...{applicationId.slice(-8)}
00521|                   </code>
00522|                 </p>
00523|               </div>
00524| 
00525|               {logs.length > 0 && (
00526|                 <>
00527|                   <h3 className="text-sm font-semibold text-zinc-700 dark:text-zinc-300">
00528|                     Recent Blocks
00529|                   </h3>
00530|                   <ul className="max-h-32 space-y-1 overflow-y-auto">
00531|                     {logs.slice(0, 5).map((log, index) => (
00532|                       <li
00533|                         key={`${log.hash}-${index}`}
00534|                         className="rounded bg-zinc-100 px-2 py-1 font-mono text-xs dark:bg-zinc-800"
00535|                       >
00536|                         <span className="font-semibold text-zinc-700 dark:text-zinc-300">
00537|                           {log.height}
00538|                         </span>
00539|                         :{" "}
00540|                         <span className="text-zinc-500 dark:text-zinc-500">
00541|                           {log.hash.slice(0, 16)}...
00542|                         </span>
00543|                       </li>
00544|                     ))}
00545|                   </ul>
00546|                 </>
00547|               )}
00548|             </div>
00549|           )}
00550|         </div>
00551|       </div>
00552|     </div>
00553|   );
00554| }
00555| 

(End of file - total 555 lines)
</file>

## Assistant

Let me check the linera-adapter to see how the client is set up:

**Tool Call: src/lib/linera-adapter.ts**
Status: Completed

<file>
00001| import type { Faucet, Client, Wallet, Application } from "@linera/client";
00002| import type { Wallet as DynamicWallet } from "@dynamic-labs/sdk-react-core";
00003| import { DynamicSigner } from "./dynamic-signer";
00004| import { loadLinera } from "./linera-loader";
00005| 
00006| const LINERA_RPC_URL = "https://faucet.testnet-conway.linera.net";
00007| const LINERA_APPLICATION_ID =
00008|   process.env.NEXT_PUBLIC_LINERA_APPLICATION_ID ||
00009|   "7517edbe70f196b08183d0d31feb76024d2cb7cc3f43931fce2c7ad10f1ea488";
00010| 
00011| export interface LineraProvider {
00012|   client: Client;
00013|   wallet: Wallet;
00014|   faucet: Faucet;
00015|   address: string;
00016|   chainId: string;
00017| }
00018| 
00019| export class LineraAdapter {
00020|   private static instance: LineraAdapter | null = null;
00021|   private provider: LineraProvider | null = null;
00022|   private application: Application | null = null;
00023| 
00024|   private connectPromise: Promise<LineraProvider> | null = null;
00025|   private onConnectionChange?: () => void;
00026| 
00027|   private constructor() {}
00028| 
00029|   static getInstance(): LineraAdapter {
00030|     if (!LineraAdapter.instance) LineraAdapter.instance = new LineraAdapter();
00031|     return LineraAdapter.instance;
00032|   }
00033| 
00034|   async connect(
00035|     dynamicWallet: DynamicWallet,
00036|     rpcUrl?: string,
00037|   ): Promise<LineraProvider> {
00038|     if (this.provider) return this.provider;
00039|     if (this.connectPromise) return this.connectPromise;
00040| 
00041|     if (!dynamicWallet) {
00042|       throw new Error("Dynamic wallet is required for Linera connection");
00043|     }
00044| 
00045|     try {
00046|       this.connectPromise = (async () => {
00047|         const { address } = dynamicWallet;
00048|         console.log("üîó Connecting with Dynamic wallet:", address);
00049| 
00050|         // Load Linera from public folder to avoid file:// URL issues
00051|         const linera = await loadLinera();
00052|         console.log("‚úÖ Linera WASM modules initialized successfully");
00053| 
00054|         const faucet = new linera.Faucet(rpcUrl || LINERA_RPC_URL);
00055|         const wallet = await faucet.createWallet();
00056|         const chainId = await faucet.claimChain(wallet, address);
00057| 
00058|         const signer = new DynamicSigner(dynamicWallet);
00059|         // Third parameter is skip_process_inbox (false = process inbox)
00060|         // Client constructor may return a Promise in WASM bindings
00061|         const client = await Promise.resolve(
00062|           new linera.Client(wallet, signer, true),
00063|         );
00064|         console.log("‚úÖ Linera wallet created successfully!");
00065|         console.log(
00066|           "üîç Client methods:",
00067|           Object.keys(client),
00068|           typeof client.frontend,
00069|         );
00070| 
00071|         this.provider = {
00072|           client,
00073|           wallet,
00074|           faucet,
00075|           chainId,
00076|           address: dynamicWallet.address,
00077|         };
00078| 
00079|         this.onConnectionChange?.();
00080|         return this.provider;
00081|       })();
00082| 
00083|       const provider = await this.connectPromise;
00084|       return provider;
00085|     } catch (error) {
00086|       console.error("Failed to connect to Linera:", error);
00087|       throw new Error(
00088|         `Failed to connect to Linera network: ${
00089|           error instanceof Error ? error.message : "Unknown error"
00090|         }`,
00091|       );
00092|     } finally {
00093|       this.connectPromise = null;
00094|     }
00095|   }
00096| 
00097|   async setApplication(appId?: string) {
00098|     if (!this.provider) throw new Error("Not connected to Linera");
00099| 
00100|     const application = await this.provider.client
00101|       .frontend()
00102|       .application(appId || LINERA_APPLICATION_ID);
00103| 
00104|     if (!application) throw new Error("Failed to get application");
00105|     console.log("‚úÖ Linera application set successfully!");
00106|     this.application = application;
00107|     this.onConnectionChange?.();
00108|   }
00109| 
00110|   async queryApplication<T>(query: object): Promise<T> {
00111|     if (!this.application) throw new Error("Application not set");
00112| 
00113|     const result = await this.application.query(JSON.stringify(query));
00114|     const response = JSON.parse(result);
00115| 
00116|     console.log("‚úÖ Linera application queried successfully!");
00117|     return response as T;
00118|   }
00119| 
00120|   /**
00121|    * Query an application on a specific chain via HTTP request to a public node service.
00122|    * This is necessary because the SDK's application() method only queries the user's default chain.
00123|    * URL format: /chains/{chain_id}/applications/{application_id}
00124|    */
00125|   async queryApplicationOnChain<T>(
00126|     chainId: string,
00127|     applicationId: string,
00128|     query: string,
00129|   ): Promise<T> {
00130|     console.log(`üîç Querying application on chain ${chainId.slice(0, 16)}...`);
00131| 
00132|     // Use the API proxy route to avoid CORS issues
00133|     const response = await fetch("/api/linera", {
00134|       method: "POST",
00135|       headers: {
00136|         "Content-Type": "application/json",
00137|       },
00138|       body: JSON.stringify({ chainId, applicationId, query }),
00139|     });
00140| 
00141|     if (!response.ok) {
00142|       const errorData = await response.json().catch(() => ({}));
00143|       throw new Error(
00144|         `Failed to query application: ${response.status} ${response.statusText} - ${errorData.details || errorData.error || "Unknown error"}`,
00145|       );
00146|     }
00147| 
00148|     const result = await response.json();
00149|     console.log("‚úÖ Cross-chain query successful!");
00150|     return result as T;
00151|   }
00152| 
00153|   getProvider(): LineraProvider {
00154|     if (!this.provider) throw new Error("Provider not set");
00155|     return this.provider;
00156|   }
00157| 
00158|   getFaucet(): Faucet {
00159|     if (!this.provider?.faucet) throw new Error("Faucet not set");
00160|     return this.provider.faucet;
00161|   }
00162| 
00163|   getWallet(): Wallet {
00164|     if (!this.provider?.wallet) throw new Error("Wallet not set");
00165|     return this.provider.wallet;
00166|   }
00167| 
00168|   getApplication(): Application {
00169|     if (!this.application) throw new Error("Application not set");
00170|     return this.application;
00171|   }
00172| 
00173|   isChainConnected(): boolean {
00174|     return this.provider !== null;
00175|   }
00176| 
00177|   isApplicationSet(): boolean {
00178|     return this.application !== null;
00179|   }
00180| 
00181|   onConnectionStateChange(callback: () => void): void {
00182|     this.onConnectionChange = callback;
00183|   }
00184| 
00185|   offConnectionStateChange(): void {
00186|     this.onConnectionChange = undefined;
00187|   }
00188| 
00189|   reset(): void {
00190|     this.application = null;
00191|     this.provider = null;
00192|     this.connectPromise = null;
00193|     this.onConnectionChange?.();
00194|   }
00195| }
00196| 
00197| // Export singleton instance
00198| export const lineraAdapter = LineraAdapter.getInstance();
00199| 

(End of file - total 199 lines)
</file>

## Assistant

Based on the DeepWiki research, the `Client` class has a `balance()` method that returns the balance of the default chain. Let me add this functionality to your adapter and component.

**Tool Call: 2 todos**
Status: Completed

[
  {
    "id": "1",
    "content": "Add getBalance method to LineraAdapter",
    "status": "in_progress",
    "priority": "high"
  },
  {
    "id": "2",
    "content": "Add balance state and display to counter-app component",
    "status": "pending",
    "priority": "high"
  }
]

**Tool Call: src/lib/linera-adapter.ts**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/lib/linera-adapter.ts
```
  isApplicationSet(): boolean {
    return this.application !== null;
  }

  /**
   * Get the balance of the connected chain.
   * Uses the Client.balance() method from @linera/client SDK.
   * @returns The balance as a string
   */
  async getBalance(): Promise<string> {
    if (!this.provider) throw new Error("Not connected to Linera");
    
    const balance = await this.provider.client.balance();
    return balance;
  }
```


**Tool Call: 1 todos**
Status: Completed

[
  {
    "content": "Add getBalance method to LineraAdapter",
    "id": "1",
    "priority": "high",
    "status": "completed"
  },
  {
    "content": "Add balance state and display to counter-app component",
    "id": "2",
    "priority": "high",
    "status": "in_progress"
  }
]

**Tool Call: src/components/counter-app.tsx**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/components/counter-app.tsx
```
  const [isLoadingDomains, setIsLoadingDomains] = useState(false);
  const [balance, setBalance] = useState<string | null>(null);
  const [isLoadingBalance, setIsLoadingBalance] = useState(false);

  const applicationId = process.env.NEXT_PUBLIC_LINERA_APPLICATION_ID || "";
```


**Tool Call: src/components/counter-app.tsx**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/components/counter-app.tsx
```
      setAllDomains([]);
      setBalance(null);
    }
  }, [isLoggedIn, primaryWallet]);
```


**Tool Call: src/components/counter-app.tsx**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/components/counter-app.tsx
```
  // Fetch chain balance
  const fetchBalance = useCallback(async () => {
    if (!chainConnected) return;
    setIsLoadingBalance(true);

    try {
      const bal = await lineraAdapter.getBalance();
      setBalance(bal);
    } catch (err) {
      console.error("Failed to fetch balance:", err);
    } finally {
      setIsLoadingBalance(false);
    }
  }, [chainConnected]);

  // Fetch registry chain ID
```


**Tool Call: src/components/counter-app.tsx**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/components/counter-app.tsx
```
  // Fetch balance when chain is connected
  useEffect(() => {
    if (chainConnected) {
      fetchBalance();
    }
  }, [chainConnected, fetchBalance]);

  // Fetch registry info when app is connected
```


**Tool Call: src/components/counter-app.tsx**
Status: Completed



Diff: {{PROJECT_ROOT}}/src/components/counter-app.tsx
```
<p className="text-zinc-700 dark:text-zinc-300">
                  <span className="font-medium">Your Chain ID:</span>{" "}
                  <code className="break-all rounded bg-zinc-100 px-2 py-1 font-mono text-xs text-zinc-600 dark:bg-zinc-800 dark:text-zinc-400">
                    {chainId
                      ? `${chainId.slice(0, 16)}...${chainId.slice(-8)}`
                      : "..."}
                  </code>
                </p>
                <p className="text-zinc-700 dark:text-zinc-300">
                  <span className="font-medium">Balance:</span>{" "}
                  <code className="rounded bg-zinc-100 px-2 py-1 font-mono text-xs text-zinc-600 dark:bg-zinc-800 dark:text-zinc-400">
                    {isLoadingBalance ? "Loading..." : balance !== null ? `${balance} LINERA` : "..."}
                  </code>
                  <button
                    type="button"
                    onClick={fetchBalance}
                    disabled={isLoadingBalance}
                    className="ml-2 rounded bg-zinc-200 px-2 py-0.5 text-xs font-medium text-zinc-700 transition-colors hover:bg-zinc-300 disabled:opacity-50 dark:bg-zinc-700 dark:text-zinc-300 dark:hover:bg-zinc-600"
                  >
                    Refresh
                  </button>
                </p>
```


**Tool Call: 0 todos**
Status: Completed

[
  {
    "content": "Add getBalance method to LineraAdapter",
    "id": "1",
    "priority": "high",
    "status": "completed"
  },
  {
    "content": "Add balance state and display to counter-app component",
    "id": "2",
    "priority": "high",
    "status": "completed"
  }
]

## Assistant

Let me verify the changes compile correctly by running a type check:

**Tool Call: Run build to check for type errors**
Status: Completed

$ next build
   ‚ñ≤ Next.js 16.0.9 (Turbopack)
   - Environments: .env.local

   Creating an optimized production build ...
 ‚úì Compiled successfully in 23.8s
   Skipping validation of types
   Collecting page data using 11 workers ...
   Generating static pages using 11 workers (0/5) ...
   Generating static pages using 11 workers (1/5) 
   Generating static pages using 11 workers (2/5) 
   Generating static pages using 11 workers (3/5) 
 ‚úì Generating static pages using 11 workers (5/5) in 2.3s
   Finalizing page optimization ...

Route (app)
‚îå ‚óã /
‚îú ‚óã /_not-found
‚îú ∆í /api/linera
‚îî ‚óã /debug


‚óã  (Static)   prerendered as static content
∆í  (Dynamic)  server-rendered on demand



## Assistant

The build succeeded. I've added the balance checking functionality to your app. Here's a summary of the changes:

## Changes Made

### 1. `src/lib/linera-adapter.ts`
Added a `getBalance()` method that uses the `Client.balance()` method from the `@linera/client` SDK:

```typescript
async getBalance(): Promise<string> {
  if (!this.provider) throw new Error("Not connected to Linera");
  const balance = await this.provider.client.balance();
  return balance;
}
```

### 2. `src/components/counter-app.tsx`
- Added `balance` and `isLoadingBalance` state variables
- Added `fetchBalance()` callback that calls `lineraAdapter.getBalance()`
- Auto-fetches balance when chain is connected
- Displays balance in the Chain Info section with a refresh button

## How It Works

According to the Linera documentation, the `Client.balance()` method:
- Returns the balance of the default chain as a string
- Internally calls `query_balance()` on the `ChainClient`
- Stages execution of incoming messages in a new block before returning the balance
- Does not synchronize with validators (reflects local state)

The balance will now be displayed in the "Chain Info" section below your Chain ID, showing something like `10 LINERA` (the typical initial balance from the faucet).

